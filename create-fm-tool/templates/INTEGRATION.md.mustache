# Integration Instructions for {{toolDisplayName}} Tool

This guide explains how to manually integrate the {{toolDisplayName}} tool into your FM Playground project.

## Generated Files

The following files have been generated for your {{toolDisplayName}} tool:

- `{{toolName}}Executor.ts` - Tool execution logic
- `{{toolName}}TextMateGrammar.ts` - Syntax highlighting and language configuration
{{#hasAdditionalInputComponent}}
- `{{toolDisplayName}}Input.tsx` - Additional input component for tool-specific options
{{/hasAdditionalInputComponent}}
{{#hasAdditionalOutputComponent}}
- `{{toolDisplayName}}Output.tsx` - Additional output component for tool-specific output display
{{/hasAdditionalOutputComponent}}

## Manual Integration Steps

### 1. Update ToolMaps.tsx

Add the following imports to the top of your `ToolMaps.tsx` file:

```typescript
// {{toolDisplayName}} tool imports
import { execute{{toolDisplayName}}Tool } from '@/../tools/{{toolName}}/{{toolName}}Executor';
import { {{toolName}}Conf, {{toolName}}Lang } from '@/../tools/{{toolName}}/{{toolName}}TextMateGrammar';
{{#hasAdditionalInputComponent}}
import {{toolDisplayName}}Input from '@/../tools/{{toolName}}/{{toolDisplayName}}Input';
{{/hasAdditionalInputComponent}}
{{#hasAdditionalOutputComponent}}
import {{toolDisplayName}}Output from '@/../tools/{{toolName}}/{{toolDisplayName}}Output';
{{/hasAdditionalOutputComponent}}
```

### 2. Update Export Maps

Add the following entries to the respective export maps in `ToolMaps.tsx`:

#### toolExecutionMap
```typescript
export const toolExecutionMap: Record<string, () => void> = {
  // ... existing entries
  {{toolId}}: execute{{toolDisplayName}}Tool,
};
```

{{#hasAdditionalInputComponent}}
#### additionalInputAreaUiMap
```typescript
export const additionalInputAreaUiMap: Record<string, React.FC<any>> = {
  // ... existing entries
  {{toolId}}: {{toolDisplayName}}Input,
};
```
{{/hasAdditionalInputComponent}}

{{#hasAdditionalOutputComponent}}
#### additonalOutputAreaUiMap
```typescript
export const additonalOutputAreaUiMap: Record<string, React.FC<any>> = {
  // ... existing entries
  {{toolId}}: {{toolDisplayName}}Output,
};
```
{{/hasAdditionalOutputComponent}}

#### toolOutputMap
```typescript
export const toolOutputMap: Record<string, React.FC<any>> = {
  // ... existing entries
  {{toolId}}: TextualOutput, // Use TextualOutput or create a custom output component
};
```

#### languageConfigMap
```typescript
export const languageConfigMap: Record<string, { tokenProvider: any; configuration: any }> = {
  // ... existing entries
  {{fileExtension}}: { tokenProvider: {{toolName}}Lang, configuration: {{toolName}}Conf },
};
```

#### fmpConfig.tools
```typescript
export const fmpConfig: FmpConfig = {
  // ... other config
  tools: {
    // ... existing tools
    {{toolName}}: { 
      name: '{{toolDisplayName}}', 
      extension: '{{fileExtension}}', 
      shortName: '{{toolId}}' 
    },
  },
};
```

### 3. Implement Tool Executor

The generated `{{toolName}}Executor.ts` file contains a template implementation. You'll need to:

1. **Add API integration**: Update the `execute{{toolDisplayName}}Tool` function to call your tool's API endpoint
2. **Handle tool output**: Process the tool's response and set appropriate output states
3. **Error handling**: Add proper error handling for tool execution failures

Example API integration:
```typescript
// Add your tool's API call here
const response = await fetch('/api/{{toolName}}/execute', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ code: editorValue, options: additionalInput })
});

const result = await response.json();
setOutput(result);
```

### 4. Configure API Endpoint (if needed)

If your tool requires a backend API:

1. **Add proxy configuration** to `vite.config.ts`:
```typescript
proxy: {
  '/{{toolName}}': {
    target: 'http://your-{{toolName}}-api:8080',
    changeOrigin: true,
    secure: false,
    rewrite: (path) => path.replace(/^\/{{toolName}}/, ''),
  },
}
```

2. **Add API URL** to your tool configuration in `fmpConfig.tools.{{toolName}}`:
```typescript
{{toolName}}: {
  name: '{{toolDisplayName}}',
  extension: '{{fileExtension}}',
  shortName: '{{toolId}}',
  apiUrl: '/{{toolName}}/execute', // Add this line
},
```

### 5. Test Integration

1. Start your development server: `npm run dev`
2. Select the {{toolDisplayName}} tool from the dropdown
3. Enter some {{toolDisplayName}} code and test execution
4. Verify syntax highlighting works correctly

### 6. Customize (Optional)

You can further customize your tool by:

{{#hasAdditionalInputComponent}}
- **Modifying input options**: Edit `{{toolDisplayName}}Input.tsx` to add tool-specific controls
{{/hasAdditionalInputComponent}}
{{#hasAdditionalOutputComponent}}
- **Customizing output display**: Edit `{{toolDisplayName}}Output.tsx` to show tool-specific information
{{/hasAdditionalOutputComponent}}
- **Enhancing syntax highlighting**: Update `{{toolName}}TextMateGrammar.ts` with more comprehensive language rules
- **Adding custom output processing**: Create a custom output component instead of using `TextualOutput`

## Need Help?

If you encounter issues during integration:

1. Check the existing tool implementations in the `tools/` directory for examples
2. Verify all import paths are correct
3. Ensure your API endpoints are properly configured
4. Test each step incrementally

For more details, refer to the [FM Playground documentation](https://github.com/se-buw/fm-playground) or the existing tool implementations.
