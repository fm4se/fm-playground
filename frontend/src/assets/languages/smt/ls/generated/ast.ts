/******************************************************************************
 * This file was generated by langium-cli 3.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const SmtTerminals = {
    BValue: /(true|false)/,
    PAR_OPEN: /\(/,
    PAR_CLOSE: /\)/,
    NUMERAL: /0|[0-9][0-9]*/,
    DECIMAL: /((0|[0-9][0-9]*)\.(0|[0-9][0-9]*))/,
    HEXADECIMAL: /#x[0-9a-fA-F]+/,
    BINARY: /#b[01]+/,
    STRING: /"(WS|PRINTABLE_CHAR)*"/,
    WS: /\s+/,
    SIMPLE_SYMBOL: /(((((((((((((((((([a-zA-Z])|(\+-))|\/)|\*)|=)|%)|\?)|!)|\.)|\$)|_)|~)|&)|\^)|<)|>)|@)(((((((((((((((((([a-zA-Z])|([0-9]))|(\+-))|\/)|\*)|=)|%)|\?)|!)|\.)|\$)|_)|~)|&)|\^)|<)|>)|@))/,
    ID: /(((([a-zA-Z])|\+)((([a-zA-Z])|([0-9]))|\+)*)|(\|([\u0020-\u007E\u0080-\u00FF])+\|))/,
    SL_COMMENT: /;[^\n\r]*/,
};

export type SmtTerminalNames = keyof typeof SmtTerminals;

export type SmtKeywordNames = 
    | ":"
    | "_"
    | "all-statistics"
    | "as"
    | "assert"
    | "assertion-stack-levels"
    | "authors"
    | "check-sat"
    | "check-sat-assuming"
    | "declare-const"
    | "declare-datatype"
    | "declare-fun"
    | "declare-sort"
    | "define-fun"
    | "define-fun-rec"
    | "define-funs-rec"
    | "define-sort"
    | "diagnostic-output-channel"
    | "echo"
    | "error-behavior"
    | "exists"
    | "exit"
    | "forall"
    | "get-assertions"
    | "get-assignment"
    | "get-info"
    | "get-model"
    | "get-option"
    | "get-proof"
    | "get-unsat-assumptions"
    | "get-unsat-core"
    | "get-value"
    | "global-declarations"
    | "interactive-mode"
    | "let"
    | "match"
    | "name"
    | "not"
    | "par"
    | "pop"
    | "print-success"
    | "produce-assertions"
    | "produce-assignments"
    | "produce-models"
    | "produce-proofs"
    | "produce-unsat-assumptions"
    | "produce-unsat-cores"
    | "push"
    | "random-seed"
    | "reason-unknown"
    | "regular-output-channel"
    | "reproducible-resource-limit"
    | "reset"
    | "reset-assertions"
    | "set-info"
    | "set-logic"
    | "set-option"
    | "verbosity"
    | "version";

export type SmtTokenNames = SmtTerminalNames | SmtKeywordNames;

export type BasicCommand = 'check-sat' | 'exit' | 'get-assertions' | 'get-assignment' | 'get-model' | 'get-proof' | 'get-unsat-assumptions' | 'get-unsat-core' | 'reset' | 'reset-assertions';

export function isBasicCommand(item: unknown): item is BasicCommand {
    return item === 'check-sat' || item === 'reset' || item === 'reset-assertions' || item === 'get-model' || item === 'exit' || item === 'get-assertions' || item === 'get-assignment' || item === 'get-proof' || item === 'get-unsat-assumptions' || item === 'get-unsat-core';
}

export type InfoFlag = Keyword;

export const InfoFlag = 'InfoFlag';

export function isInfoFlag(item: unknown): item is InfoFlag {
    return reflection.isInstance(item, InfoFlag);
}

export type Option = Attribute;

export const Option = 'Option';

export function isOption(item: unknown): item is Option {
    return reflection.isInstance(item, Option);
}

export type SpecConstant = string;

export function isSpecConstant(item: unknown): item is SpecConstant {
    return (typeof item === 'string' && (/0|[0-9][0-9]*/.test(item) || /((0|[0-9][0-9]*)\.(0|[0-9][0-9]*))/.test(item) || /#x[0-9a-fA-F]+/.test(item) || /#b[01]+/.test(item) || /"(WS|PRINTABLE_CHAR)*"/.test(item)));
}

export interface Attribute extends AstNode {
    readonly $container: Command | Term;
    readonly $type: 'Attribute';
    keyWord: Keyword;
    value?: AttributeValue;
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface AttributeValue extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'AttributeValue';
    const?: SpecConstant;
    exprs: Array<SExpr>;
    symbol?: SmtSymbol;
}

export const AttributeValue = 'AttributeValue';

export function isAttributeValue(item: unknown): item is AttributeValue {
    return reflection.isInstance(item, AttributeValue);
}

export interface Command extends AstNode {
    readonly $type: 'Command' | 'DataTypeDec' | 'FunctionDef' | 'Sort' | 'Term';
    basicCommand?: BasicCommand;
    functionDec: Array<FunctionDec>;
    infoFlag?: InfoFlag;
    name?: Attribute | Keyword | string;
    option?: Option;
    paramSorts: Array<Sort>;
    propLiteral: Array<PropLiteral>;
    returnSort?: Sort;
    sorts: Array<Sort>;
    symbol?: Array<SmtSymbol> | SmtSymbol;
    term?: Array<Term> | Term;
}

export const Command = 'Command';

export function isCommand(item: unknown): item is Command {
    return reflection.isInstance(item, Command);
}

export interface ConstructorDec extends AstNode {
    readonly $container: DataTypeDec;
    readonly $type: 'ConstructorDec';
    selectorDec: Array<SelectorDec>;
    symbol: SmtSymbol;
}

export const ConstructorDec = 'ConstructorDec';

export function isConstructorDec(item: unknown): item is ConstructorDec {
    return reflection.isInstance(item, ConstructorDec);
}

export interface FunctionDec extends AstNode {
    readonly $container: Command | Identifier | SelectorDec | Sort | SortedVar;
    readonly $type: 'FunctionDec' | 'Sort';
    symbol: SmtSymbol;
    var: Array<SortedVar>;
}

export const FunctionDec = 'FunctionDec';

export function isFunctionDec(item: unknown): item is FunctionDec {
    return reflection.isInstance(item, FunctionDec);
}

export interface Identifier extends AstNode {
    readonly $container: Identifier | Sort | Term;
    readonly $type: 'Identifier';
    id?: Identifier;
    indices: Array<Index>;
    sort?: Sort;
    symbol?: string;
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface Index extends AstNode {
    readonly $container: Identifier;
    readonly $type: 'Index';
    num?: string;
    symbol?: SmtSymbol;
}

export const Index = 'Index';

export function isIndex(item: unknown): item is Index {
    return reflection.isInstance(item, Index);
}

export interface Keyword extends AstNode {
    readonly $container: Attribute | Command | SExpr;
    readonly $type: 'Keyword';
    simpleSymbol: string;
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface MatchCase extends AstNode {
    readonly $container: Term;
    readonly $type: 'MatchCase';
    pattern: Pattern;
    term: Term;
}

export const MatchCase = 'MatchCase';

export function isMatchCase(item: unknown): item is MatchCase {
    return reflection.isInstance(item, MatchCase);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    commands: Array<Command>;
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Pattern extends AstNode {
    readonly $container: MatchCase;
    readonly $type: 'Pattern';
    symbol: SmtSymbol;
    symbols: Array<SmtSymbol>;
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface PropLiteral extends AstNode {
    readonly $container: Command;
    readonly $type: 'PropLiteral';
    symbol: SmtSymbol;
}

export const PropLiteral = 'PropLiteral';

export function isPropLiteral(item: unknown): item is PropLiteral {
    return reflection.isInstance(item, PropLiteral);
}

export interface SelectorDec extends AstNode {
    readonly $container: ConstructorDec;
    readonly $type: 'SelectorDec';
    sotr: Sort;
    symbol: SmtSymbol;
}

export const SelectorDec = 'SelectorDec';

export function isSelectorDec(item: unknown): item is SelectorDec {
    return reflection.isInstance(item, SelectorDec);
}

export interface SExpr extends AstNode {
    readonly $container: AttributeValue | SExpr;
    readonly $type: 'SExpr';
    const?: SpecConstant;
    exprs: Array<SExpr>;
    keyWord?: Keyword;
    symb?: SmtSymbol;
}

export const SExpr = 'SExpr';

export function isSExpr(item: unknown): item is SExpr {
    return reflection.isInstance(item, SExpr);
}

export interface SmtSymbol extends AstNode {
    readonly $container: AttributeValue | Command | ConstructorDec | DataTypeDec | FunctionDec | FunctionDef | Index | Pattern | PropLiteral | SExpr | SelectorDec | SortedVar | VarBindings;
    readonly $type: 'SmtSymbol';
    symbol: string;
}

export const SmtSymbol = 'SmtSymbol';

export function isSmtSymbol(item: unknown): item is SmtSymbol {
    return reflection.isInstance(item, SmtSymbol);
}

export interface SortedVar extends AstNode {
    readonly $container: FunctionDec | FunctionDef | Term;
    readonly $type: 'SortedVar';
    sort: Sort;
    symbol: SmtSymbol;
}

export const SortedVar = 'SortedVar';

export function isSortedVar(item: unknown): item is SortedVar {
    return reflection.isInstance(item, SortedVar);
}

export interface VarBindings extends AstNode {
    readonly $container: Term;
    readonly $type: 'VarBindings';
    symbol: SmtSymbol;
    term: Term;
}

export const VarBindings = 'VarBindings';

export function isVarBindings(item: unknown): item is VarBindings {
    return reflection.isInstance(item, VarBindings);
}

export interface DataTypeDec extends Command {
    readonly $type: 'DataTypeDec';
    conttructorDec: Array<ConstructorDec>;
    symbol: Array<SmtSymbol>;
}

export const DataTypeDec = 'DataTypeDec';

export function isDataTypeDec(item: unknown): item is DataTypeDec {
    return reflection.isInstance(item, DataTypeDec);
}

export interface FunctionDef extends Command {
    readonly $container: Command | Identifier | MatchCase | SelectorDec | Sort | SortedVar | Term | VarBindings;
    readonly $type: 'FunctionDef' | 'Sort' | 'Term';
    symbol: SmtSymbol;
    var: Array<SortedVar>;
}

export const FunctionDef = 'FunctionDef';

export function isFunctionDef(item: unknown): item is FunctionDef {
    return reflection.isInstance(item, FunctionDef);
}

export interface Sort extends Command {
    readonly $container: Command | Identifier | SelectorDec | Sort | SortedVar;
    readonly $type: 'Sort';
    identifier?: Identifier;
    indetifier?: Identifier;
    sorts: Array<Sort>;
}

export const Sort = 'Sort';

export function isSort(item: unknown): item is Sort {
    return reflection.isInstance(item, Sort);
}

export interface Term extends FunctionDef {
    readonly $container: Command | MatchCase | Term | VarBindings;
    readonly $type: 'Term';
    attributes: Array<Attribute>;
    cases: Array<MatchCase>;
    const?: SpecConstant;
    identifier?: Identifier;
    term?: Term;
    var: Array<SortedVar>;
}

export const Term = 'Term';

export function isTerm(item: unknown): item is Term {
    return reflection.isInstance(item, Term);
}

export type SmtAstType = {
    Attribute: Attribute
    AttributeValue: AttributeValue
    Command: Command
    ConstructorDec: ConstructorDec
    DataTypeDec: DataTypeDec
    FunctionDec: FunctionDec
    FunctionDef: FunctionDef
    Identifier: Identifier
    Index: Index
    InfoFlag: InfoFlag
    Keyword: Keyword
    MatchCase: MatchCase
    Model: Model
    Option: Option
    Pattern: Pattern
    PropLiteral: PropLiteral
    SExpr: SExpr
    SelectorDec: SelectorDec
    SmtSymbol: SmtSymbol
    Sort: Sort
    SortedVar: SortedVar
    Term: Term
    VarBindings: VarBindings
}

export class SmtAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [Attribute, AttributeValue, Command, ConstructorDec, DataTypeDec, FunctionDec, FunctionDef, Identifier, Index, InfoFlag, Keyword, MatchCase, Model, Option, Pattern, PropLiteral, SExpr, SelectorDec, SmtSymbol, Sort, SortedVar, Term, VarBindings];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Attribute: {
                return this.isSubtype(Option, supertype);
            }
            case DataTypeDec:
            case FunctionDef: {
                return this.isSubtype(Command, supertype);
            }
            case Keyword: {
                return this.isSubtype(InfoFlag, supertype);
            }
            case Sort: {
                return this.isSubtype(Command, supertype) || this.isSubtype(FunctionDec, supertype) || this.isSubtype(FunctionDef, supertype);
            }
            case Term: {
                return this.isSubtype(FunctionDef, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case Attribute: {
                return {
                    name: Attribute,
                    properties: [
                        { name: 'keyWord' },
                        { name: 'value' }
                    ]
                };
            }
            case AttributeValue: {
                return {
                    name: AttributeValue,
                    properties: [
                        { name: 'const' },
                        { name: 'exprs', defaultValue: [] },
                        { name: 'symbol' }
                    ]
                };
            }
            case Command: {
                return {
                    name: Command,
                    properties: [
                        { name: 'basicCommand' },
                        { name: 'functionDec', defaultValue: [] },
                        { name: 'infoFlag' },
                        { name: 'name' },
                        { name: 'option' },
                        { name: 'paramSorts', defaultValue: [] },
                        { name: 'propLiteral', defaultValue: [] },
                        { name: 'returnSort' },
                        { name: 'sorts', defaultValue: [] },
                        { name: 'symbol' },
                        { name: 'term' }
                    ]
                };
            }
            case ConstructorDec: {
                return {
                    name: ConstructorDec,
                    properties: [
                        { name: 'selectorDec', defaultValue: [] },
                        { name: 'symbol' }
                    ]
                };
            }
            case FunctionDec: {
                return {
                    name: FunctionDec,
                    properties: [
                        { name: 'symbol' },
                        { name: 'var', defaultValue: [] }
                    ]
                };
            }
            case Identifier: {
                return {
                    name: Identifier,
                    properties: [
                        { name: 'id' },
                        { name: 'indices', defaultValue: [] },
                        { name: 'sort' },
                        { name: 'symbol' }
                    ]
                };
            }
            case Index: {
                return {
                    name: Index,
                    properties: [
                        { name: 'num' },
                        { name: 'symbol' }
                    ]
                };
            }
            case Keyword: {
                return {
                    name: Keyword,
                    properties: [
                        { name: 'simpleSymbol' }
                    ]
                };
            }
            case MatchCase: {
                return {
                    name: MatchCase,
                    properties: [
                        { name: 'pattern' },
                        { name: 'term' }
                    ]
                };
            }
            case Model: {
                return {
                    name: Model,
                    properties: [
                        { name: 'commands', defaultValue: [] }
                    ]
                };
            }
            case Pattern: {
                return {
                    name: Pattern,
                    properties: [
                        { name: 'symbol' },
                        { name: 'symbols', defaultValue: [] }
                    ]
                };
            }
            case PropLiteral: {
                return {
                    name: PropLiteral,
                    properties: [
                        { name: 'symbol' }
                    ]
                };
            }
            case SelectorDec: {
                return {
                    name: SelectorDec,
                    properties: [
                        { name: 'sotr' },
                        { name: 'symbol' }
                    ]
                };
            }
            case SExpr: {
                return {
                    name: SExpr,
                    properties: [
                        { name: 'const' },
                        { name: 'exprs', defaultValue: [] },
                        { name: 'keyWord' },
                        { name: 'symb' }
                    ]
                };
            }
            case SmtSymbol: {
                return {
                    name: SmtSymbol,
                    properties: [
                        { name: 'symbol' }
                    ]
                };
            }
            case SortedVar: {
                return {
                    name: SortedVar,
                    properties: [
                        { name: 'sort' },
                        { name: 'symbol' }
                    ]
                };
            }
            case VarBindings: {
                return {
                    name: VarBindings,
                    properties: [
                        { name: 'symbol' },
                        { name: 'term' }
                    ]
                };
            }
            case DataTypeDec: {
                return {
                    name: DataTypeDec,
                    properties: [
                        { name: 'basicCommand' },
                        { name: 'conttructorDec', defaultValue: [] },
                        { name: 'functionDec', defaultValue: [] },
                        { name: 'infoFlag' },
                        { name: 'name' },
                        { name: 'option' },
                        { name: 'paramSorts', defaultValue: [] },
                        { name: 'propLiteral', defaultValue: [] },
                        { name: 'returnSort' },
                        { name: 'sorts', defaultValue: [] },
                        { name: 'symbol', defaultValue: [] },
                        { name: 'term' }
                    ]
                };
            }
            case FunctionDef: {
                return {
                    name: FunctionDef,
                    properties: [
                        { name: 'basicCommand' },
                        { name: 'functionDec', defaultValue: [] },
                        { name: 'infoFlag' },
                        { name: 'name' },
                        { name: 'option' },
                        { name: 'paramSorts', defaultValue: [] },
                        { name: 'propLiteral', defaultValue: [] },
                        { name: 'returnSort' },
                        { name: 'sorts', defaultValue: [] },
                        { name: 'symbol' },
                        { name: 'term' },
                        { name: 'var', defaultValue: [] }
                    ]
                };
            }
            case Sort: {
                return {
                    name: Sort,
                    properties: [
                        { name: 'basicCommand' },
                        { name: 'functionDec', defaultValue: [] },
                        { name: 'identifier' },
                        { name: 'indetifier' },
                        { name: 'infoFlag' },
                        { name: 'name' },
                        { name: 'option' },
                        { name: 'paramSorts', defaultValue: [] },
                        { name: 'propLiteral', defaultValue: [] },
                        { name: 'returnSort' },
                        { name: 'sorts', defaultValue: [] },
                        { name: 'symbol' },
                        { name: 'term' },
                        { name: 'var', defaultValue: [] }
                    ]
                };
            }
            case Term: {
                return {
                    name: Term,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'basicCommand' },
                        { name: 'cases', defaultValue: [] },
                        { name: 'const' },
                        { name: 'functionDec', defaultValue: [] },
                        { name: 'identifier' },
                        { name: 'infoFlag' },
                        { name: 'name' },
                        { name: 'option' },
                        { name: 'paramSorts', defaultValue: [] },
                        { name: 'propLiteral', defaultValue: [] },
                        { name: 'returnSort' },
                        { name: 'sorts', defaultValue: [] },
                        { name: 'symbol' },
                        { name: 'term' },
                        { name: 'var', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new SmtAstReflection();
