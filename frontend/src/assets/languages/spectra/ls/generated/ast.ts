/******************************************************************************
 * This file was generated by langium-cli 3.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const SpectraTerminals = {
    ID: /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,
    INT: /[0-9]+/,
    STRING: /("((\\(((("|\\)|n)|r)|t))|((?!(\\|"))[\s\S]*?))*")/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*|--[^\n\r]*/,
    WS: /((( |	)|\r)|\n)+/,
};

export type SpectraTerminalNames = keyof typeof SpectraTerminals;

export type SpectraKeywordNames = 
    | "!"
    | "!="
    | "%"
    | "&"
    | "("
    | "()"
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "->"
    | "."
    | ".."
    | ".all"
    | ".any"
    | ".max"
    | ".min"
    | ".prod"
    | ".sum"
    | "/"
    | ":"
    | ":="
    | ";"
    | "<"
    | "<->"
    | "<="
    | "="
    | ">"
    | ">="
    | "?"
    | "FALSE"
    | "G"
    | "GE"
    | "GEF"
    | "GF"
    | "H"
    | "HISTORICALLY"
    | "Int"
    | "O"
    | "ONCE"
    | "PREV"
    | "S"
    | "SINCE"
    | "T"
    | "TRIGGERED"
    | "TRUE"
    | "Y"
    | "["
    | "]"
    | "alw"
    | "alwEv"
    | "always"
    | "alwaysEventually"
    | "and"
    | "asm"
    | "assumption"
    | "aux"
    | "auxvar"
    | "boolean"
    | "counter"
    | "dec:"
    | "define"
    | "env"
    | "envvar"
    | "exists"
    | "false"
    | "forall"
    | "gar"
    | "guarantee"
    | "iff"
    | "implies"
    | "import"
    | "in"
    | "inc:"
    | "ini"
    | "initially"
    | "input"
    | "keep"
    | "mod"
    | "module"
    | "modulo"
    | "monitor"
    | "next"
    | "not"
    | "or"
    | "out"
    | "output"
    | "overflow:"
    | "pattern"
    | "predicate"
    | "regexp"
    | "regtest"
    | "reset:"
    | "spec"
    | "sys"
    | "sysvar"
    | "trans"
    | "trig"
    | "true"
    | "type"
    | "underflow:"
    | "var"
    | "weight"
    | "xor"
    | "{"
    | "|"
    | "|=>"
    | "}"
    | "~";

export type SpectraTokenNames = SpectraTerminalNames | SpectraKeywordNames;

export type Decl = Counter | Define | DefineRegExp | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | RegexpTest | TypeDef | Var | WeightDef;

export const Decl = 'Decl';

export function isDecl(item: unknown): item is Decl {
    return reflection.isInstance(item, Decl);
}

export type OverflowMethod = 'false' | 'keep' | 'modulo';

export type OverflowMethod_FALSE = 'false';

export function isOverflowMethod_FALSE(item: unknown): item is OverflowMethod_FALSE {
    return item === 'false';
}

export type OverflowMethod_KEEP = 'keep';

export function isOverflowMethod_KEEP(item: unknown): item is OverflowMethod_KEEP {
    return item === 'keep';
}

export type OverflowMethod_MODULO = 'modulo';

export function isOverflowMethod_MODULO(item: unknown): item is OverflowMethod_MODULO {
    return item === 'modulo';
}

export type PredicateOrPatternReferrable = Pattern | Predicate;

export const PredicateOrPatternReferrable = 'PredicateOrPatternReferrable';

export function isPredicateOrPatternReferrable(item: unknown): item is PredicateOrPatternReferrable {
    return reflection.isInstance(item, PredicateOrPatternReferrable);
}

export type Referrable = Counter | DefineDecl | DefineRegExpDecl | DomainVarDecl | Monitor | PatternParam | TypeConstant | TypedParam | TypedParamList | Var | VarDecl;

export const Referrable = 'Referrable';

export function isReferrable(item: unknown): item is Referrable {
    return reflection.isInstance(item, Referrable);
}

export type TemporalExpression = Constant | QuantifierExpr | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr;

export const TemporalExpression = 'TemporalExpression';

export function isTemporalExpression(item: unknown): item is TemporalExpression {
    return reflection.isInstance(item, TemporalExpression);
}

export type TOK_SEMI = ';';

export function isTOK_SEMI(item: unknown): item is TOK_SEMI {
    return item === ';';
}

export type TypeConstantLiteral = number | string;


export type VarOwner = 'aux' | 'auxvar' | 'env' | 'envvar' | 'in' | 'input' | 'out' | 'output' | 'sys' | 'sysvar';

export interface BooleanTerm extends AstNode {
    readonly $container: RegExpr;
    readonly $type: 'BooleanTerm';
    relExpr?: TemporalExpression;
}

export const BooleanTerm = 'BooleanTerm';

export function isBooleanTerm(item: unknown): item is BooleanTerm {
    return reflection.isInstance(item, BooleanTerm);
}

export interface Constant extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'Constant';
    booleanValue?: 'FALSE' | 'TRUE' | 'false' | 'true';
    integerValue?: number;
}

export const Constant = 'Constant';

export function isConstant(item: unknown): item is Constant {
    return reflection.isInstance(item, Constant);
}

export interface Counter extends AstNode {
    readonly $container: Model;
    readonly $type: 'Counter' | 'TOK_SEMI';
    decPred: Array<TemporalExpression>;
    incPred: Array<TemporalExpression>;
    initial: Array<TemporalExpression>;
    name: string;
    overflowMethod: Array<OverflowMethod>;
    range: Subrange;
    resetPred: Array<TemporalExpression>;
    underflowMethod: Array<OverflowMethod>;
}

export const Counter = 'Counter';

export function isCounter(item: unknown): item is Counter {
    return reflection.isInstance(item, Counter);
}

export interface Define extends AstNode {
    readonly $container: Model;
    readonly $type: 'Define';
    defineList: Array<DefineDecl>;
}

export const Define = 'Define';

export function isDefine(item: unknown): item is Define {
    return reflection.isInstance(item, Define);
}

export interface DefineArray extends AstNode {
    readonly $container: DefineArray | DefineDecl;
    readonly $type: 'DefineArray';
    innerArrays: Array<DefineArray>;
    simpleExprs: Array<TemporalExpression>;
}

export const DefineArray = 'DefineArray';

export function isDefineArray(item: unknown): item is DefineArray {
    return reflection.isInstance(item, DefineArray);
}

export interface DefineDecl extends AstNode {
    readonly $container: Define;
    readonly $type: 'DefineDecl' | 'TOK_SEMI';
    dimensions: Array<SizeDefineDecl>;
    innerArray: DefineArray;
    name: string;
    simpleExpr: TemporalExpression;
}

export const DefineDecl = 'DefineDecl';

export function isDefineDecl(item: unknown): item is DefineDecl {
    return reflection.isInstance(item, DefineDecl);
}

export interface DefineRegExp extends AstNode {
    readonly $container: Model;
    readonly $type: 'DefineRegExp';
    defineRegsList: Array<DefineRegExpDecl>;
}

export const DefineRegExp = 'DefineRegExp';

export function isDefineRegExp(item: unknown): item is DefineRegExp {
    return reflection.isInstance(item, DefineRegExp);
}

export interface DefineRegExpDecl extends AstNode {
    readonly $container: DefineRegExp;
    readonly $type: 'DefineRegExpDecl' | 'TOK_SEMI';
    exp: RegExpr;
    name: string;
}

export const DefineRegExpDecl = 'DefineRegExpDecl';

export function isDefineRegExpDecl(item: unknown): item is DefineRegExpDecl {
    return reflection.isInstance(item, DefineRegExpDecl);
}

export interface DomainVarDecl extends AstNode {
    readonly $container: QuantifierExpr;
    readonly $type: 'DomainVarDecl';
    domainType: VarType;
    name: string;
}

export const DomainVarDecl = 'DomainVarDecl';

export function isDomainVarDecl(item: unknown): item is DomainVarDecl {
    return reflection.isInstance(item, DomainVarDecl);
}

export interface EXGar extends AstNode {
    readonly $container: Model;
    readonly $type: 'EXGar' | 'TOK_SEMI';
    elements: Array<TemporalExpression>;
    name?: string;
    regExp: RegExpr;
    regExpPointer: Reference<DefineRegExpDecl>;
}

export const EXGar = 'EXGar';

export function isEXGar(item: unknown): item is EXGar {
    return reflection.isInstance(item, EXGar);
}

export interface Import extends AstNode {
    readonly $container: Model;
    readonly $type: 'Import';
    importURI: string;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface LTLAsm extends AstNode {
    readonly $container: Model;
    readonly $type: 'LTLAsm' | 'TOK_SEMI';
    justice?: 'GF' | 'alwEv' | 'alwaysEventually';
    name: string;
    params?: TypedParamList;
    safety?: 'G' | 'trans';
    stateInv?: 'alw' | 'always';
    temporalExpr: TemporalExpression;
    trig: Trigger;
}

export const LTLAsm = 'LTLAsm';

export function isLTLAsm(item: unknown): item is LTLAsm {
    return reflection.isInstance(item, LTLAsm);
}

export interface LTLGar extends AstNode {
    readonly $container: Model;
    readonly $type: 'LTLGar' | 'TOK_SEMI';
    justice?: 'GF' | 'alwEv' | 'alwaysEventually';
    name: string;
    params?: TypedParamList;
    safety?: 'G' | 'trans';
    stateInv?: 'alw' | 'always';
    temporalExpr: TemporalExpression;
    trig: Trigger;
}

export const LTLGar = 'LTLGar';

export function isLTLGar(item: unknown): item is LTLGar {
    return reflection.isInstance(item, LTLGar);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    elements: Array<Decl>;
    imports: Array<Import>;
    name: string;
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Monitor extends AstNode {
    readonly $container: Model;
    readonly $type: 'Monitor' | 'TOK_SEMI';
    initial: Array<TemporalExpression>;
    name: string;
    safety: Array<TemporalExpression>;
    stateInv: Array<TemporalExpression>;
    type: VarType;
}

export const Monitor = 'Monitor';

export function isMonitor(item: unknown): item is Monitor {
    return reflection.isInstance(item, Monitor);
}

export interface Pattern extends AstNode {
    readonly $container: Model;
    readonly $type: 'Pattern' | 'TOK_SEMI';
    initial: Array<TemporalExpression>;
    justice: Array<TemporalExpression>;
    name: string;
    params?: PatternParamList;
    safety: Array<TemporalExpression>;
    stateInv: Array<TemporalExpression>;
    varDeclList: Array<VarDecl>;
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface PatternParam extends AstNode {
    readonly $container: PatternParamList;
    readonly $type: 'PatternParam';
    name: string;
}

export const PatternParam = 'PatternParam';

export function isPatternParam(item: unknown): item is PatternParam {
    return reflection.isInstance(item, PatternParam);
}

export interface PatternParamList extends AstNode {
    readonly $container: Pattern;
    readonly $type: 'PatternParamList';
    params: Array<PatternParam>;
}

export const PatternParamList = 'PatternParamList';

export function isPatternParamList(item: unknown): item is PatternParamList {
    return reflection.isInstance(item, PatternParamList);
}

export interface Predicate extends AstNode {
    readonly $container: Model;
    readonly $type: 'Predicate' | 'TOK_SEMI';
    body: TemporalExpression;
    name: string;
    params?: TypedParamList;
}

export const Predicate = 'Predicate';

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate);
}

export interface QuantifierExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'QuantifierExpr';
    domainVar: DomainVarDecl;
    operator: 'exists' | 'forall';
    temporalExpr: TemporalExpression;
}

export const QuantifierExpr = 'QuantifierExpr';

export function isQuantifierExpr(item: unknown): item is QuantifierExpr {
    return reflection.isInstance(item, QuantifierExpr);
}

export interface RegExpr extends AstNode {
    readonly $type: 'BinaryRegExp' | 'CompRegExp' | 'RegExpr' | 'UnaryRegExp';
    assrt?: BooleanTerm;
    empty: boolean;
    val?: 'FALSE' | 'TRUE' | 'false' | 'true';
}

export const RegExpr = 'RegExpr';

export function isRegExpr(item: unknown): item is RegExpr {
    return reflection.isInstance(item, RegExpr);
}

export interface RegexpTest extends AstNode {
    readonly $container: Model;
    readonly $type: 'RegexpTest' | 'TOK_SEMI';
    name?: string;
    regExp: RegExpr;
    regExpPointer: Reference<DefineRegExpDecl>;
}

export const RegexpTest = 'RegexpTest';

export function isRegexpTest(item: unknown): item is RegexpTest {
    return reflection.isInstance(item, RegexpTest);
}

export interface SizeDefineDecl extends AstNode {
    readonly $container: DefineDecl | Subrange | VarType;
    readonly $type: 'SizeDefineDecl';
    arithExp?: TemporalExpression;
    sizeDef?: Reference<DefineDecl>;
    value?: number;
}

export const SizeDefineDecl = 'SizeDefineDecl';

export function isSizeDefineDecl(item: unknown): item is SizeDefineDecl {
    return reflection.isInstance(item, SizeDefineDecl);
}

export interface Subrange extends AstNode {
    readonly $container: Counter | VarType;
    readonly $type: 'Subrange';
    from: SizeDefineDecl;
    to: SizeDefineDecl;
}

export const Subrange = 'Subrange';

export function isSubrange(item: unknown): item is Subrange {
    return reflection.isInstance(item, Subrange);
}

export interface TemporalAdditiveExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalAdditiveExpr';
    elements: Array<TemporalExpression>;
    operator: Array<'+' | '-'>;
}

export const TemporalAdditiveExpr = 'TemporalAdditiveExpr';

export function isTemporalAdditiveExpr(item: unknown): item is TemporalAdditiveExpr {
    return reflection.isInstance(item, TemporalAdditiveExpr);
}

export interface TemporalAndExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalAndExpr';
    elements: Array<TemporalExpression>;
    operator: Array<'&' | 'and'>;
}

export const TemporalAndExpr = 'TemporalAndExpr';

export function isTemporalAndExpr(item: unknown): item is TemporalAndExpr {
    return reflection.isInstance(item, TemporalAndExpr);
}

export interface TemporalBinaryExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalBinaryExpr';
    elements: Array<TemporalExpression>;
    operator: Array<'S' | 'SINCE' | 'T' | 'TRIGGERED'>;
}

export const TemporalBinaryExpr = 'TemporalBinaryExpr';

export function isTemporalBinaryExpr(item: unknown): item is TemporalBinaryExpr {
    return reflection.isInstance(item, TemporalBinaryExpr);
}

export interface TemporalIffExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalIffExpr';
    elements: Array<TemporalExpression>;
    operator: '<->' | 'iff';
}

export const TemporalIffExpr = 'TemporalIffExpr';

export function isTemporalIffExpr(item: unknown): item is TemporalIffExpr {
    return reflection.isInstance(item, TemporalIffExpr);
}

export interface TemporalImpExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalImpExpr';
    implication: TemporalExpression;
    left: TemporalExpression;
    operator: '->' | 'implies';
}

export const TemporalImpExpr = 'TemporalImpExpr';

export function isTemporalImpExpr(item: unknown): item is TemporalImpExpr {
    return reflection.isInstance(item, TemporalImpExpr);
}

export interface TemporalInExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalInExpr';
    left: TemporalExpression;
    not: boolean;
    operator: 'in';
    values: Array<ValueInRange>;
}

export const TemporalInExpr = 'TemporalInExpr';

export function isTemporalInExpr(item: unknown): item is TemporalInExpr {
    return reflection.isInstance(item, TemporalInExpr);
}

export interface TemporalMultiplicativeExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalMultiplicativeExpr';
    elements: Array<TemporalExpression>;
    operator: Array<'*' | '/'>;
}

export const TemporalMultiplicativeExpr = 'TemporalMultiplicativeExpr';

export function isTemporalMultiplicativeExpr(item: unknown): item is TemporalMultiplicativeExpr {
    return reflection.isInstance(item, TemporalMultiplicativeExpr);
}

export interface TemporalOrExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalOrExpr';
    elements: Array<TemporalExpression>;
    operator: Array<'or' | 'xor' | '|'>;
}

export const TemporalOrExpr = 'TemporalOrExpr';

export function isTemporalOrExpr(item: unknown): item is TemporalOrExpr {
    return reflection.isInstance(item, TemporalOrExpr);
}

export interface TemporalPrimaryExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalPrimaryExpr';
    index: Array<TemporalExpression>;
    operator?: '!' | '-' | '.all' | '.any' | '.max' | '.min' | '.prod' | '.sum' | 'next' | 'regexp';
    pointer?: Reference<Referrable>;
    predPatt?: Reference<PredicateOrPatternReferrable>;
    predPattParams: Array<TemporalExpression>;
    regexp?: RegExpr;
    regexpPointer?: Reference<DefineRegExpDecl>;
    temporalExpression?: TemporalExpression;
    tpe?: TemporalExpression;
}

export const TemporalPrimaryExpr = 'TemporalPrimaryExpr';

export function isTemporalPrimaryExpr(item: unknown): item is TemporalPrimaryExpr {
    return reflection.isInstance(item, TemporalPrimaryExpr);
}

export interface TemporalRelationalExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalRelationalExpr';
    left: TemporalExpression;
    operator: '!=' | '<' | '<=' | '=' | '>' | '>=';
    right: TemporalExpression;
}

export const TemporalRelationalExpr = 'TemporalRelationalExpr';

export function isTemporalRelationalExpr(item: unknown): item is TemporalRelationalExpr {
    return reflection.isInstance(item, TemporalRelationalExpr);
}

export interface TemporalRemainderExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalRemainderExpr';
    left: TemporalExpression;
    operator: '%' | 'mod';
    right: TemporalExpression;
}

export const TemporalRemainderExpr = 'TemporalRemainderExpr';

export function isTemporalRemainderExpr(item: unknown): item is TemporalRemainderExpr {
    return reflection.isInstance(item, TemporalRemainderExpr);
}

export interface TemporalUnaryExpr extends AstNode {
    readonly $container: BooleanTerm | Counter | DefineArray | DefineDecl | EXGar | LTLAsm | LTLGar | Monitor | Pattern | Predicate | QuantifierExpr | SizeDefineDecl | TemporalAdditiveExpr | TemporalAndExpr | TemporalBinaryExpr | TemporalIffExpr | TemporalImpExpr | TemporalInExpr | TemporalMultiplicativeExpr | TemporalOrExpr | TemporalPrimaryExpr | TemporalRelationalExpr | TemporalRemainderExpr | TemporalUnaryExpr | WeightDef;
    readonly $type: 'TemporalUnaryExpr';
    kinds: 'H' | 'HISTORICALLY' | 'O' | 'ONCE' | 'PREV' | 'Y';
    tue: TemporalExpression;
}

export const TemporalUnaryExpr = 'TemporalUnaryExpr';

export function isTemporalUnaryExpr(item: unknown): item is TemporalUnaryExpr {
    return reflection.isInstance(item, TemporalUnaryExpr);
}

export interface Trigger extends AstNode {
    readonly $container: LTLAsm | LTLGar;
    readonly $type: 'Trigger';
    effectPointer?: Reference<DefineRegExpDecl>;
    effectRegExp?: RegExpr;
    initPointer?: Reference<DefineRegExpDecl>;
    initRegExp?: RegExpr;
}

export const Trigger = 'Trigger';

export function isTrigger(item: unknown): item is Trigger {
    return reflection.isInstance(item, Trigger);
}

export interface TypeConstant extends AstNode {
    readonly $container: VarType;
    readonly $type: 'TypeConstant';
    name: TypeConstantLiteral;
}

export const TypeConstant = 'TypeConstant';

export function isTypeConstant(item: unknown): item is TypeConstant {
    return reflection.isInstance(item, TypeConstant);
}

export interface TypeDef extends AstNode {
    readonly $container: Model;
    readonly $type: 'TOK_SEMI' | 'TypeDef';
    name: string;
    type: VarType;
}

export const TypeDef = 'TypeDef';

export function isTypeDef(item: unknown): item is TypeDef {
    return reflection.isInstance(item, TypeDef);
}

export interface TypedParam extends AstNode {
    readonly $container: TypedParamList;
    readonly $type: 'TypedParam';
    name: string;
    type: VarType;
}

export const TypedParam = 'TypedParam';

export function isTypedParam(item: unknown): item is TypedParam {
    return reflection.isInstance(item, TypedParam);
}

export interface TypedParamList extends AstNode {
    readonly $container: LTLAsm | LTLGar | Predicate;
    readonly $type: 'TypedParamList';
    params: Array<TypedParam>;
}

export const TypedParamList = 'TypedParamList';

export function isTypedParamList(item: unknown): item is TypedParamList {
    return reflection.isInstance(item, TypedParamList);
}

export interface ValueInRange extends AstNode {
    readonly $container: TemporalInExpr;
    readonly $type: 'ValueInRange';
    booleanValue?: 'FALSE' | 'TRUE' | 'false' | 'true';
    const?: Reference<TypeConstant>;
    from?: number;
    int?: number;
    multi: boolean;
    to?: number;
}

export const ValueInRange = 'ValueInRange';

export function isValueInRange(item: unknown): item is ValueInRange {
    return reflection.isInstance(item, ValueInRange);
}

export interface Var extends AstNode {
    readonly $container: Model;
    readonly $type: 'TOK_SEMI' | 'Var';
    kind: VarOwner;
    name: string;
    type: VarType;
}

export const Var = 'Var';

export function isVar(item: unknown): item is Var {
    return reflection.isInstance(item, Var);
}

export interface VarDecl extends AstNode {
    readonly $container: Pattern;
    readonly $type: 'TOK_SEMI' | 'VarDecl';
    name: string;
    type: VarType;
}

export const VarDecl = 'VarDecl';

export function isVarDecl(item: unknown): item is VarDecl {
    return reflection.isInstance(item, VarDecl);
}

export interface VarType extends AstNode {
    readonly $container: DomainVarDecl | Monitor | TypeDef | TypedParam | Var | VarDecl;
    readonly $type: 'VarType';
    const: Array<TypeConstant>;
    dimensions: Array<SizeDefineDecl>;
    name?: 'boolean';
    subr?: Subrange;
    type?: Reference<TypeDef>;
}

export const VarType = 'VarType';

export function isVarType(item: unknown): item is VarType {
    return reflection.isInstance(item, VarType);
}

export interface WeightDef extends AstNode {
    readonly $container: Model;
    readonly $type: 'TOK_SEMI' | 'WeightDef';
    definition: TemporalExpression;
    name: string;
    negative?: '-';
    value: number;
}

export const WeightDef = 'WeightDef';

export function isWeightDef(item: unknown): item is WeightDef {
    return reflection.isInstance(item, WeightDef);
}

export interface BinaryRegExp extends RegExpr {
    readonly $type: 'BinaryRegExp';
    left: RegExpr;
    op?: '&' | '|';
    right: RegExpr;
}

export const BinaryRegExp = 'BinaryRegExp';

export function isBinaryRegExp(item: unknown): item is BinaryRegExp {
    return reflection.isInstance(item, BinaryRegExp);
}

export interface CompRegExp extends RegExpr {
    readonly $type: 'CompRegExp';
    comp: '~';
    left: RegExpr;
}

export const CompRegExp = 'CompRegExp';

export function isCompRegExp(item: unknown): item is CompRegExp {
    return reflection.isInstance(item, CompRegExp);
}

export interface UnaryRegExp extends RegExpr {
    readonly $type: 'UnaryRegExp';
    atLeast?: number;
    exactRepetition?: number;
    from?: number;
    fromDefine?: Reference<DefineDecl>;
    haveAtLeast: boolean;
    haveExactRepetition: boolean;
    haveRange: boolean;
    kleened: boolean;
    left: RegExpr;
    plus: boolean;
    questionMark: boolean;
    to?: number;
    toDefine?: Reference<DefineDecl>;
}

export const UnaryRegExp = 'UnaryRegExp';

export function isUnaryRegExp(item: unknown): item is UnaryRegExp {
    return reflection.isInstance(item, UnaryRegExp);
}

export type SpectraAstType = {
    BinaryRegExp: BinaryRegExp
    BooleanTerm: BooleanTerm
    CompRegExp: CompRegExp
    Constant: Constant
    Counter: Counter
    Decl: Decl
    Define: Define
    DefineArray: DefineArray
    DefineDecl: DefineDecl
    DefineRegExp: DefineRegExp
    DefineRegExpDecl: DefineRegExpDecl
    DomainVarDecl: DomainVarDecl
    EXGar: EXGar
    Import: Import
    LTLAsm: LTLAsm
    LTLGar: LTLGar
    Model: Model
    Monitor: Monitor
    Pattern: Pattern
    PatternParam: PatternParam
    PatternParamList: PatternParamList
    Predicate: Predicate
    PredicateOrPatternReferrable: PredicateOrPatternReferrable
    QuantifierExpr: QuantifierExpr
    Referrable: Referrable
    RegExpr: RegExpr
    RegexpTest: RegexpTest
    SizeDefineDecl: SizeDefineDecl
    Subrange: Subrange
    TemporalAdditiveExpr: TemporalAdditiveExpr
    TemporalAndExpr: TemporalAndExpr
    TemporalBinaryExpr: TemporalBinaryExpr
    TemporalExpression: TemporalExpression
    TemporalIffExpr: TemporalIffExpr
    TemporalImpExpr: TemporalImpExpr
    TemporalInExpr: TemporalInExpr
    TemporalMultiplicativeExpr: TemporalMultiplicativeExpr
    TemporalOrExpr: TemporalOrExpr
    TemporalPrimaryExpr: TemporalPrimaryExpr
    TemporalRelationalExpr: TemporalRelationalExpr
    TemporalRemainderExpr: TemporalRemainderExpr
    TemporalUnaryExpr: TemporalUnaryExpr
    Trigger: Trigger
    TypeConstant: TypeConstant
    TypeDef: TypeDef
    TypedParam: TypedParam
    TypedParamList: TypedParamList
    UnaryRegExp: UnaryRegExp
    ValueInRange: ValueInRange
    Var: Var
    VarDecl: VarDecl
    VarType: VarType
    WeightDef: WeightDef
}

export class SpectraAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [BinaryRegExp, BooleanTerm, CompRegExp, Constant, Counter, Decl, Define, DefineArray, DefineDecl, DefineRegExp, DefineRegExpDecl, DomainVarDecl, EXGar, Import, LTLAsm, LTLGar, Model, Monitor, Pattern, PatternParam, PatternParamList, Predicate, PredicateOrPatternReferrable, QuantifierExpr, Referrable, RegExpr, RegexpTest, SizeDefineDecl, Subrange, TemporalAdditiveExpr, TemporalAndExpr, TemporalBinaryExpr, TemporalExpression, TemporalIffExpr, TemporalImpExpr, TemporalInExpr, TemporalMultiplicativeExpr, TemporalOrExpr, TemporalPrimaryExpr, TemporalRelationalExpr, TemporalRemainderExpr, TemporalUnaryExpr, Trigger, TypeConstant, TypeDef, TypedParam, TypedParamList, UnaryRegExp, ValueInRange, Var, VarDecl, VarType, WeightDef];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BinaryRegExp:
            case CompRegExp:
            case UnaryRegExp: {
                return this.isSubtype(RegExpr, supertype);
            }
            case Constant:
            case QuantifierExpr:
            case TemporalAdditiveExpr:
            case TemporalAndExpr:
            case TemporalBinaryExpr:
            case TemporalIffExpr:
            case TemporalImpExpr:
            case TemporalInExpr:
            case TemporalMultiplicativeExpr:
            case TemporalOrExpr:
            case TemporalPrimaryExpr:
            case TemporalRelationalExpr:
            case TemporalRemainderExpr:
            case TemporalUnaryExpr: {
                return this.isSubtype(TemporalExpression, supertype);
            }
            case Counter:
            case Monitor:
            case Var: {
                return this.isSubtype(Decl, supertype) || this.isSubtype(Referrable, supertype);
            }
            case Define:
            case DefineRegExp:
            case EXGar:
            case LTLAsm:
            case LTLGar:
            case RegexpTest:
            case TypeDef:
            case WeightDef: {
                return this.isSubtype(Decl, supertype);
            }
            case DefineDecl:
            case DefineRegExpDecl:
            case DomainVarDecl:
            case PatternParam:
            case TypeConstant:
            case TypedParam:
            case TypedParamList:
            case VarDecl: {
                return this.isSubtype(Referrable, supertype);
            }
            case Pattern:
            case Predicate: {
                return this.isSubtype(Decl, supertype) || this.isSubtype(PredicateOrPatternReferrable, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'EXGar:regExpPointer':
            case 'RegexpTest:regExpPointer':
            case 'TemporalPrimaryExpr:regexpPointer':
            case 'Trigger:effectPointer':
            case 'Trigger:initPointer': {
                return DefineRegExpDecl;
            }
            case 'SizeDefineDecl:sizeDef':
            case 'UnaryRegExp:fromDefine':
            case 'UnaryRegExp:toDefine': {
                return DefineDecl;
            }
            case 'TemporalPrimaryExpr:pointer': {
                return Referrable;
            }
            case 'TemporalPrimaryExpr:predPatt': {
                return PredicateOrPatternReferrable;
            }
            case 'ValueInRange:const': {
                return TypeConstant;
            }
            case 'VarType:type': {
                return TypeDef;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case BooleanTerm: {
                return {
                    name: BooleanTerm,
                    properties: [
                        { name: 'relExpr' }
                    ]
                };
            }
            case Constant: {
                return {
                    name: Constant,
                    properties: [
                        { name: 'booleanValue' },
                        { name: 'integerValue' }
                    ]
                };
            }
            case Counter: {
                return {
                    name: Counter,
                    properties: [
                        { name: 'decPred', defaultValue: [] },
                        { name: 'incPred', defaultValue: [] },
                        { name: 'initial', defaultValue: [] },
                        { name: 'name' },
                        { name: 'overflowMethod', defaultValue: [] },
                        { name: 'range' },
                        { name: 'resetPred', defaultValue: [] },
                        { name: 'underflowMethod', defaultValue: [] }
                    ]
                };
            }
            case Define: {
                return {
                    name: Define,
                    properties: [
                        { name: 'defineList', defaultValue: [] }
                    ]
                };
            }
            case DefineArray: {
                return {
                    name: DefineArray,
                    properties: [
                        { name: 'innerArrays', defaultValue: [] },
                        { name: 'simpleExprs', defaultValue: [] }
                    ]
                };
            }
            case DefineDecl: {
                return {
                    name: DefineDecl,
                    properties: [
                        { name: 'dimensions', defaultValue: [] },
                        { name: 'innerArray' },
                        { name: 'name' },
                        { name: 'simpleExpr' }
                    ]
                };
            }
            case DefineRegExp: {
                return {
                    name: DefineRegExp,
                    properties: [
                        { name: 'defineRegsList', defaultValue: [] }
                    ]
                };
            }
            case DefineRegExpDecl: {
                return {
                    name: DefineRegExpDecl,
                    properties: [
                        { name: 'exp' },
                        { name: 'name' }
                    ]
                };
            }
            case DomainVarDecl: {
                return {
                    name: DomainVarDecl,
                    properties: [
                        { name: 'domainType' },
                        { name: 'name' }
                    ]
                };
            }
            case EXGar: {
                return {
                    name: EXGar,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'name' },
                        { name: 'regExp' },
                        { name: 'regExpPointer' }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'importURI' }
                    ]
                };
            }
            case LTLAsm: {
                return {
                    name: LTLAsm,
                    properties: [
                        { name: 'justice' },
                        { name: 'name' },
                        { name: 'params' },
                        { name: 'safety' },
                        { name: 'stateInv' },
                        { name: 'temporalExpr' },
                        { name: 'trig' }
                    ]
                };
            }
            case LTLGar: {
                return {
                    name: LTLGar,
                    properties: [
                        { name: 'justice' },
                        { name: 'name' },
                        { name: 'params' },
                        { name: 'safety' },
                        { name: 'stateInv' },
                        { name: 'temporalExpr' },
                        { name: 'trig' }
                    ]
                };
            }
            case Model: {
                return {
                    name: Model,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'imports', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case Monitor: {
                return {
                    name: Monitor,
                    properties: [
                        { name: 'initial', defaultValue: [] },
                        { name: 'name' },
                        { name: 'safety', defaultValue: [] },
                        { name: 'stateInv', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case Pattern: {
                return {
                    name: Pattern,
                    properties: [
                        { name: 'initial', defaultValue: [] },
                        { name: 'justice', defaultValue: [] },
                        { name: 'name' },
                        { name: 'params' },
                        { name: 'safety', defaultValue: [] },
                        { name: 'stateInv', defaultValue: [] },
                        { name: 'varDeclList', defaultValue: [] }
                    ]
                };
            }
            case PatternParam: {
                return {
                    name: PatternParam,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case PatternParamList: {
                return {
                    name: PatternParamList,
                    properties: [
                        { name: 'params', defaultValue: [] }
                    ]
                };
            }
            case Predicate: {
                return {
                    name: Predicate,
                    properties: [
                        { name: 'body' },
                        { name: 'name' },
                        { name: 'params' }
                    ]
                };
            }
            case QuantifierExpr: {
                return {
                    name: QuantifierExpr,
                    properties: [
                        { name: 'domainVar' },
                        { name: 'operator' },
                        { name: 'temporalExpr' }
                    ]
                };
            }
            case RegExpr: {
                return {
                    name: RegExpr,
                    properties: [
                        { name: 'assrt' },
                        { name: 'empty', defaultValue: false },
                        { name: 'val' }
                    ]
                };
            }
            case RegexpTest: {
                return {
                    name: RegexpTest,
                    properties: [
                        { name: 'name' },
                        { name: 'regExp' },
                        { name: 'regExpPointer' }
                    ]
                };
            }
            case SizeDefineDecl: {
                return {
                    name: SizeDefineDecl,
                    properties: [
                        { name: 'arithExp' },
                        { name: 'sizeDef' },
                        { name: 'value' }
                    ]
                };
            }
            case Subrange: {
                return {
                    name: Subrange,
                    properties: [
                        { name: 'from' },
                        { name: 'to' }
                    ]
                };
            }
            case TemporalAdditiveExpr: {
                return {
                    name: TemporalAdditiveExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator', defaultValue: [] }
                    ]
                };
            }
            case TemporalAndExpr: {
                return {
                    name: TemporalAndExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator', defaultValue: [] }
                    ]
                };
            }
            case TemporalBinaryExpr: {
                return {
                    name: TemporalBinaryExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator', defaultValue: [] }
                    ]
                };
            }
            case TemporalIffExpr: {
                return {
                    name: TemporalIffExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator' }
                    ]
                };
            }
            case TemporalImpExpr: {
                return {
                    name: TemporalImpExpr,
                    properties: [
                        { name: 'implication' },
                        { name: 'left' },
                        { name: 'operator' }
                    ]
                };
            }
            case TemporalInExpr: {
                return {
                    name: TemporalInExpr,
                    properties: [
                        { name: 'left' },
                        { name: 'not', defaultValue: false },
                        { name: 'operator' },
                        { name: 'values', defaultValue: [] }
                    ]
                };
            }
            case TemporalMultiplicativeExpr: {
                return {
                    name: TemporalMultiplicativeExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator', defaultValue: [] }
                    ]
                };
            }
            case TemporalOrExpr: {
                return {
                    name: TemporalOrExpr,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'operator', defaultValue: [] }
                    ]
                };
            }
            case TemporalPrimaryExpr: {
                return {
                    name: TemporalPrimaryExpr,
                    properties: [
                        { name: 'index', defaultValue: [] },
                        { name: 'operator' },
                        { name: 'pointer' },
                        { name: 'predPatt' },
                        { name: 'predPattParams', defaultValue: [] },
                        { name: 'regexp' },
                        { name: 'regexpPointer' },
                        { name: 'temporalExpression' },
                        { name: 'tpe' }
                    ]
                };
            }
            case TemporalRelationalExpr: {
                return {
                    name: TemporalRelationalExpr,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case TemporalRemainderExpr: {
                return {
                    name: TemporalRemainderExpr,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case TemporalUnaryExpr: {
                return {
                    name: TemporalUnaryExpr,
                    properties: [
                        { name: 'kinds' },
                        { name: 'tue' }
                    ]
                };
            }
            case Trigger: {
                return {
                    name: Trigger,
                    properties: [
                        { name: 'effectPointer' },
                        { name: 'effectRegExp' },
                        { name: 'initPointer' },
                        { name: 'initRegExp' }
                    ]
                };
            }
            case TypeConstant: {
                return {
                    name: TypeConstant,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case TypeDef: {
                return {
                    name: TypeDef,
                    properties: [
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case TypedParam: {
                return {
                    name: TypedParam,
                    properties: [
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case TypedParamList: {
                return {
                    name: TypedParamList,
                    properties: [
                        { name: 'params', defaultValue: [] }
                    ]
                };
            }
            case ValueInRange: {
                return {
                    name: ValueInRange,
                    properties: [
                        { name: 'booleanValue' },
                        { name: 'const' },
                        { name: 'from' },
                        { name: 'int' },
                        { name: 'multi', defaultValue: false },
                        { name: 'to' }
                    ]
                };
            }
            case Var: {
                return {
                    name: Var,
                    properties: [
                        { name: 'kind' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case VarDecl: {
                return {
                    name: VarDecl,
                    properties: [
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case VarType: {
                return {
                    name: VarType,
                    properties: [
                        { name: 'const', defaultValue: [] },
                        { name: 'dimensions', defaultValue: [] },
                        { name: 'name' },
                        { name: 'subr' },
                        { name: 'type' }
                    ]
                };
            }
            case WeightDef: {
                return {
                    name: WeightDef,
                    properties: [
                        { name: 'definition' },
                        { name: 'name' },
                        { name: 'negative' },
                        { name: 'value' }
                    ]
                };
            }
            case BinaryRegExp: {
                return {
                    name: BinaryRegExp,
                    properties: [
                        { name: 'assrt' },
                        { name: 'empty', defaultValue: false },
                        { name: 'left' },
                        { name: 'op' },
                        { name: 'right' },
                        { name: 'val' }
                    ]
                };
            }
            case CompRegExp: {
                return {
                    name: CompRegExp,
                    properties: [
                        { name: 'assrt' },
                        { name: 'comp' },
                        { name: 'empty', defaultValue: false },
                        { name: 'left' },
                        { name: 'val' }
                    ]
                };
            }
            case UnaryRegExp: {
                return {
                    name: UnaryRegExp,
                    properties: [
                        { name: 'assrt' },
                        { name: 'atLeast' },
                        { name: 'empty', defaultValue: false },
                        { name: 'exactRepetition' },
                        { name: 'from' },
                        { name: 'fromDefine' },
                        { name: 'haveAtLeast', defaultValue: false },
                        { name: 'haveExactRepetition', defaultValue: false },
                        { name: 'haveRange', defaultValue: false },
                        { name: 'kleened', defaultValue: false },
                        { name: 'left' },
                        { name: 'plus', defaultValue: false },
                        { name: 'questionMark', defaultValue: false },
                        { name: 'to' },
                        { name: 'toDefine' },
                        { name: 'val' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new SpectraAstReflection();
